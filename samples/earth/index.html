<html lang="en">
    <head>
        <title>Earth</title>
        <meta charset="utf-8" />

        <link href="earth.css" rel="stylesheet">

        <script src="../common/webgl-debug.js"></script>
        <script src="../common/RequestAnimationFrame.js"></script>

        <script src="../../src/cube.js"></script>
        <script src="../../src/core/core.js"></script>
        <script src="../../src/core/math/math.js"></script>
        <script src="../../src/core/math/Vector3.js"></script>
        <script src="../../src/core/math/Matrix4.js"></script>
        <script src="../../src/core/Utilities.js"></script>
        <script src="../../src/core/RenderVisitor.js"></script>
        <script src="../../src/core/Node.js"></script>
        <script src="../../src/core/ArrayNode.js"></script>
        <script src="../../src/core/BufferSetNode.js"></script>
        <script src="../../src/core/OutputToBufferSet.js"></script>
        <script src="../../src/core/GeometryNode.js"></script>
        <script src="../../src/core/MaterialNode.js"></script>
        <script src="../../src/core/MeshNode.js"></script>
        <script src="../../src/core/OpticNode.js"></script>
        <script src="../../src/core/OrthographicOpticNode.js"></script>
        <script src="../../src/core/TransformNode.js"></script>
        <script src="../../src/core/RotationXYZNode.js"></script>
        <script src="../../src/core/ScalingNode.js"></script>
        <script src="../../src/core/TranslationNode.js"></script>
        <script src="../../src/core/FaceCameraNode.js"></script>
        <script src="../../src/core/FaceObjectNode.js"></script>
        <script src="../../src/core/TranslationCompensatorNode.js"></script>
        <script src="../../src/core/TransformStackNode.js"></script>
        <script src="../../src/core/ViewNode.js"></script>
        <script src="../../src/core/ViewportNode.js"></script>
        <script src="../../src/core/GeometryHelpers.js"></script>
        <script src="../../src/core/ShaderNode.js"></script>
        <script src="../../src/core/TextureNode.js"></script>
        <script src="../../src/core/ResourceLoader.js"></script>
        <script src="../../src/core/ShaderManager.js"></script>
        <script src="../../src/core/TextureManager.js"></script>
        <script src="../../src/core/MaterialBindingNode.js"></script>
        <script src="../../src/core/MaterialNode.js"></script>
        <script src="../../src/core/LightDirectionalNode.js"></script>
        <script src="../../src/core/LightPositionalNode.js"></script>
        <script src="../../src/core/CameraNode.js"></script>
        <script src="../../src/core/Object.js"></script>
        <script src="../../src/core/Scene.js"></script>
        <script src="../../src/core/Engine.js"></script>
        <script src="../../src/core/Renderer.js"></script>

        <!--
                <script src="../../deploy/js/green3.min.js"></script>
        -->
        <!--
                <script src="../../deploy/js/green3.js"></script>
        -->

        <script id="shaded-vertex-shader" type="x-shader/x-vertex">

// http://fabiensanglard.net/bumpMapping/index.php
        
          attribute vec3 aPosition;
          attribute vec4 aColor;
          attribute vec3 aNormal;
          attribute vec2 aUV;
          attribute vec4 tangent;

          uniform mat4 u_normalMatrix;
          uniform mat4 u_matrix;
          uniform mat4 u_projection;
          
          struct Light {
            int type;
            vec4 color;
            vec3 direction;
            vec3 position;
          };
          uniform Light lights[4];
          uniform int lightsCount;

          varying vec4 v_position;
          varying vec4 v_color;
          varying vec4 v_normal;
          varying vec2 v_TextureCoord;
          varying vec3 lightVec;
          varying vec3 halfVec;
          varying vec3 eyeVec;

          void main() {
            vec3 n = normalize(u_normalMatrix * vec4(aNormal, 0.0)).xyz;
            vec3 t = normalize(u_normalMatrix * vec4(tangent.xyz, 0.0)).xyz;
            vec3 b = cross(n, t) * tangent.w;

            vec3 vertexPosition = (u_matrix * vec4(aPosition, 1.0)).xyz;
            vec3 lightDir = normalize(lights[0].position - vertexPosition);
              
            // transform light and half angle vectors by tangent basis
            vec3 v;
            v.x = dot(lightDir, t);
            v.y = dot(lightDir, b);
            v.z = dot(lightDir, n);
            lightVec = normalize(v);
              
            v.x = dot (vertexPosition, t);
            v.y = dot (vertexPosition, b);
            v.z = dot (vertexPosition, n);
            eyeVec = normalize(v);

            vertexPosition = normalize(vertexPosition);
              
            /* Normalize the halfVector to pass it to the fragment shader */

            // No need to divide by two, the result is normalized anyway.
            // vec3 halfVector = normalize((vertexPosition + lightDir) / 2.0); 
            vec3 halfVector = normalize(vertexPosition + lightDir);
            v.x = dot(halfVector, t);
            v.y = dot(halfVector, b);
            v.z = dot(halfVector, n);

            // No need to normalize, t,b,n and halfVector are normal vectors.
            //normalize (v);
            halfVec = v ;

            v_position = u_matrix * vec4(aPosition, 1.0);
            v_normal = u_normalMatrix * vec4(aNormal, 0.0);
            v_color = aColor;
            v_TextureCoord = aUV;

            gl_Position = u_projection * u_matrix * vec4(aPosition, 1.0);
            // gl_PointSize = 4.0;
          }
        </script>

        <script id="shaded-fragment-shader" type="x-shader/x-fragment">
          precision mediump float;
          
          uniform sampler2D texture0;
          uniform sampler2D texture1;
          uniform sampler2D texture2;
          uniform sampler2D texture3;

          struct Light {
            int type;
            vec4 color;
            vec3 direction;
            vec3 position;
          };
          uniform Light lights[4];
          uniform int lightsCount;
          
          varying vec4 v_position;
          varying vec4 v_normal;
          varying vec4 v_color;
          varying vec2 v_TextureCoord;
          varying vec3 lightVec;
          varying vec3 halfVec;
          varying vec3 eyeVec;

          void main() {


            // lookup normal from normal map, move from [0,1] to  [-1, 1] range, normalize
            vec3 normal = 2.0 * texture2D(texture3, v_TextureCoord.st).rgb - 1.0;
            normal = normalize(normal);

            vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
            Light l = lights[0];

            if (l.type == 0) {
              color += l.color;
            }
            else {
              vec3 L = lightVec;
              vec3 N = normal;
              float lambertTerm = max(dot(L, N), 0.0);
              vec4 f1 = texture2D(texture0, v_TextureCoord.st);
//              if (lambertTerm > 0.0) {
                  vec4 f2 = texture2D(texture1, v_TextureCoord.st);
                  color += mix(f1, f2, lambertTerm);
//                  color = f2 * lambertTerm;
//                  vec4 f3 = texture2D(texture2, v_TextureCoord.st);
//                  float specularTerm = pow(max(dot(halfVec, N), 0.0), 60.0);
//                  float specularTerm = pow(max(dot(reflect(-lightVec, normal), halfVec), 0.0), 25.0);
//                  color += vec4(specularTerm * f3.rgb, 1.0);
/*              }
              else {
                  color += f1;
              }*/
            }

            gl_FragColor = color;
          }
        </script>

        <script id="halo-vertex-shader" type="x-shader/x-vertex">
          attribute vec3 aPosition;
          attribute vec4 aColor;
          attribute vec3 aNormal;
          attribute vec2 aUV;

          uniform mat4 u_normalMatrix;
          uniform mat4 u_matrix;
          uniform mat4 u_projection;

          varying vec4 v_color;
          varying vec2 v_TextureCoord;

          void main() {
            gl_Position = u_projection * u_matrix * vec4(aPosition, 1.0);
            v_color = aColor;
            v_TextureCoord = aUV;
          }
        </script>

        <script id="halo-fragment-shader" type="x-shader/x-fragment">
          precision mediump float;

          float radius = 1.0;
          float halo = 2.0;
          float ratio = radius/halo;
          float complInvRatio = 1.0/(1.0 - ratio);

          varying vec4 v_color;
          varying vec2 v_TextureCoord;

          void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(center, v_TextureCoord)/0.5;
            if (dist <= ratio) {
              discard; // drop fragment if hidden
            }
            dist = (dist - ratio) * complInvRatio;
            gl_FragColor = vec4(0.0, 0.1, 1.0, 1.0-dist);
          }
        </script>

        <script id="flat-vertex-shader" type="x-shader/x-vertex">
          attribute vec3 aPosition;
          attribute vec4 aColor;
          attribute vec3 aNormal;
          attribute vec2 aUV;

          uniform mat4 u_normalMatrix;
          uniform mat4 u_matrix;
          uniform mat4 u_projection;

          varying vec2 v_TextureCoord;

          void main() {
            gl_Position = u_projection * u_matrix * vec4(aPosition, 1.0);
            v_TextureCoord = aUV;
          }
        </script>

        <script id="flat-fragment-shader" type="x-shader/x-fragment">
          precision mediump float;

          uniform sampler2D texture0;

          varying vec2 v_TextureCoord;

          void main() {
            gl_FragColor = texture2D(texture0, v_TextureCoord.st);
          }
        </script>

    </head>

    <body>
      <div id="title">
        <h1>- EARTH -</h1>
      </div>
      <script src="./earth.js"></script>
    </body>
</html>
